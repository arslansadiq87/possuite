// Pos.Server.Api/Program.cs
using System;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using Pos.Domain.Sync;
using Pos.Server.Api;

var builder = WebApplication.CreateBuilder(args);

// ?????????????????????????????????????????????????????????????????????????????
// Config
// ?????????????????????????????????????????????????????????????????????????????
var apiKey = builder.Configuration["Security:ApiKey"]; // from appsettings.Production.json or env

// ?????????????????????????????????????????????????????????????????????????????
// EF Core / PostgreSQL
//   Connection string precedence:
//   1) ConnectionStrings:ServerDb (appsettings.*)
//   2) ENV var: DT_PG_CS
// ?????????????????????????????????????????????????????????????????????????????
builder.Services.AddDbContext<ServerDbContext>(opt =>
{
    var cs = builder.Configuration.GetConnectionString("ServerDb")
             ?? Environment.GetEnvironmentVariable("DT_PG_CS")
             ?? throw new InvalidOperationException("PostgreSQL connection string not configured.");

    opt.UseNpgsql(cs, npg =>
    {
        npg.EnableRetryOnFailure(5, TimeSpan.FromSeconds(5), null);
    });

    opt.EnableDetailedErrors();
    opt.EnableSensitiveDataLogging(builder.Environment.IsDevelopment());
});

// ?????????????????????????????????????????????????????????????????????????????
// Swagger / CORS
// ?????????????????????????????????????????????????????????????????????????????
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();
builder.Services.AddCors();

// If you run locally without Docker, you can uncomment to force a specific port.
// builder.WebHost.UseUrls("http://localhost:5089");

var app = builder.Build();

// ?????????????????????????????????????????????????????????????????????????????
// Apply database migrations at startup
// ?????????????????????????????????????????????????????????????????????????????
using (var scope = app.Services.CreateScope())
{
    var db = scope.ServiceProvider.GetRequiredService<ServerDbContext>();
    await db.Database.MigrateAsync();
}

// ?????????????????????????????????????????????????????????????????????????????
// API Key middleware (protect everything except /api/health and Swagger)
//   Client must send header: X-Api-Key: <value>
// ?????????????????????????????????????????????????????????????????????????????
app.Use(async (ctx, next) =>
{
    var path = ctx.Request.Path.Value?.ToLowerInvariant() ?? "";

    // Allow health & swagger without API key
    if (path.StartsWith("/api/health") || path.StartsWith("/swagger"))
    {
        await next();
        return;
    }

    // Enforce API key if configured
    if (!string.IsNullOrWhiteSpace(apiKey))
    {
        if (!ctx.Request.Headers.TryGetValue("X-Api-Key", out var key) || key != apiKey)
        {
            ctx.Response.StatusCode = 401;
            await ctx.Response.WriteAsync("Missing/invalid X-Api-Key");
            return;
        }
    }

    await next();
});

// ?????????????????????????????????????????????????????????????????????????????
// CORS (open; tighten later to your domain/IPs if desired)
// ?????????????????????????????????????????????????????????????????????????????
app.UseCors(p => p
    .AllowAnyHeader()
    .AllowAnyMethod()
    .SetIsOriginAllowed(_ => true));

// ?????????????????????????????????????????????????????????????????????????????
// Swagger
// ?????????????????????????????????????????????????????????????????????????????
app.UseSwagger();
app.UseSwaggerUI();

// ?????????????????????????????????????????????????????????????????????????????
// Health
// ?????????????????????????????????????????????????????????????????????????????
app.MapGet("/api/health", () => Results.Ok(new { ok = true, utc = DateTime.UtcNow }));

// ?????????????????????????????????????????????????????????????????????????????
// Sync: PUSH  (client -> server append to change feed)
// ?????????????????????????????????????????????????????????????????????????????
app.MapPost("/api/sync/push", async (
    [FromBody] SyncBatch batch,
    [FromServices] ServerDbContext db,
    CancellationToken ct) =>
{
    if (batch?.Changes == null || batch.Changes.Count == 0)
        return Results.Ok(new { Accepted = 0, ServerToken = 0L });

    var terminalId = string.IsNullOrWhiteSpace(batch.TerminalId) ? "unknown" : batch.TerminalId;

    foreach (var ch in batch.Changes)
    {
        db.Changes.Add(new ServerChange
        {
            // Token is DB-generated (identity/sequence)
            Entity = ch.Entity,
            PublicId = ch.PublicId,
            Op = (int)ch.Op,
            PayloadJson = ch.PayloadJson,
            TsUtc = ch.TsUtc,
            SourceTerminal = terminalId
        });
    }

    var accepted = await db.SaveChangesAsync(ct);

    // Latest token
    var lastToken = await db.Changes
        .OrderByDescending(c => c.Token)
        .Select(c => c.Token)
        .FirstOrDefaultAsync(ct);

    // Track cursor for this terminal
    var cursor = await db.Cursors.FirstOrDefaultAsync(c => c.TerminalId == terminalId, ct);
    if (cursor == null)
    {
        cursor = new ServerCursor { TerminalId = terminalId, LastToken = lastToken };
        db.Cursors.Add(cursor);
    }
    else
    {
        cursor.LastToken = lastToken;
    }

    await db.SaveChangesAsync(ct);

    return Results.Ok(new { Accepted = accepted, ServerToken = lastToken });
});

// ?????????????????????????????????????????????????????????????????????????????
// Sync: PULL  (server -> client read changes since token)
// ?????????????????????????????????????????????????????????????????????????????
app.MapGet("/api/sync/pull", async (
    [FromQuery] string terminalId,
    [FromQuery] long sinceToken,
    [FromQuery] int max,
    [FromServices] ServerDbContext db,
    CancellationToken ct) =>
{
    if (max <= 0 || max > 1000) max = 500;

    // Don’t echo the same terminal’s writes back to itself
    var changes = await db.Changes
        .Where(c => c.Token > sinceToken && c.SourceTerminal != terminalId)
        .OrderBy(c => c.Token)
        .Take(max)
        .Select(c => new SyncEnvelope
        {
            Entity = c.Entity,
            Op = (SyncOp)c.Op,
            PublicId = c.PublicId,
            PayloadJson = c.PayloadJson,
            TsUtc = c.TsUtc
        })
        .ToListAsync(ct);

    var lastToken = await db.Changes
        .OrderByDescending(c => c.Token)
        .Select(c => c.Token)
        .FirstOrDefaultAsync(ct);

    // Update cursor
    var cursor = await db.Cursors.FirstOrDefaultAsync(c => c.TerminalId == terminalId, ct);
    if (cursor == null)
    {
        cursor = new ServerCursor { TerminalId = terminalId, LastToken = lastToken };
        db.Cursors.Add(cursor);
    }
    else
    {
        cursor.LastToken = lastToken;
    }

    await db.SaveChangesAsync(ct);

    return Results.Ok(new { Changes = changes, ServerToken = lastToken });
});

app.Run();
